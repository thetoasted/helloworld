<?php
/*
 * Take the account details of a user who has updated there details
 * and then send a notification to a list of registered servers
 * $account 
 *
 * @param string $sso_id
 * Users sso_id from auth.itv.com.
 */

function waf_notifier_notify_user_update($sso_id) {
  wdd("waf_notifier_notify_user_update");
  $notify_clients = waf_client_get_clients();
  wdd($notify_clients, "waf_notifier clients");
  foreach ($notify_clients as $client) {
    waf_notifier_notify_client($client, $sso_id);
  }
  watchdog('waf_notifier', 'Notify complete for ' . sso_id);
}

/* 
 * Notify a single client of a user update
 *
 *
 * @param oject $client
 * Client oject is config details of client sites i.e. xFactor
 *
 * @param string $sso_id
 * Users sso_id from auth.itv.com.
 *
 * return true/false
 */
function waf_notifier_notify_client($client, $sso_id) {
  wdd("waf_notifier_notify_client");
  wdd($client,"client=");
  wdd($sso_id,"sso_id=");
  $hash_string = waf_server_hash_create($sso_id, $client->waf_client_site_shared_key );
  return waf_notifier_http_request($client, $sso_id, $hash_string);
}

/*
 * Make a http request to the clients REST servers
 *
 * @param oject $client
 * Client oject is config details of client sites i.e. xFactor
 *
 * @param string $sso_id
 * Users sso_id from auth.itv.com.
 *
 * @param string $hash_string
 * Authentification hash string
 *
 * return true/false
 */
function waf_notifier_http_request($client, $sso_id, $hash_string) {
wdd("waf_notifier_http_request");


  //ok lets work out if this internal or external
  //all external connection need to go via the proxy
  if ( $client->proxy_status ) {
wdd("using curl");
    //ok lets setup the url
    $url = $client->site_host_url . '/api/user_service/user-update/' . $sso_id;
    //ok lets setup curl for the connection
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_URL, urldecode($url));
    curl_setopt($ch, CURLOPT_COOKIE, $cm_cookie);
    curl_setopt($ch, CURLOPT_HTTPPROXYTUNNEL, 1);
    curl_setopt($ch, CURLOPT_PROXY, variable_get('proxy_server'));
    curl_setopt($ch, CURLOPT_PROXYPORT, variable_get('proxy_port'));
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 60);
    $result = curl_exec($ch);
wdd($result, "result=");

    if ( $result === FALSE ) {
	    watchdog('waf_notifier', 'Notify failed to ' . $client->waf_client_site_service_url . ' connect:');
      return FALSE;
    }

    $xml = @simplexml_load_string($result);
wdd($xml, "XML=");
    if ( isset($xml->user) ) { 
	    watchdog('waf_notifier', 'Notify failed to ' . $client->waf_client_site_service_url . ' error:'
        . $xml_obj->error->error_code . " " . $xml_obj->error->error_message );
      return FALSE;
    }
    return TRUE;

  }
  else {
wdd("using drupal http");
    //ok lets do the internal connections and we will request json here

    //ok lets setup the url
    $url = $client->site_host_url . '/api/client_services/user-update/' . $sso_id . '.json';
    $options = array(
      'method' => 'PUT',
      'headers' => array(
          'Accept' => 'application/json',
          'Digest' => $hash_string,
      ),
    );
    $response = drupal_http_request($url, $options);
wdd($response, "response");
    $res_obj = json_decode($response->data);
 
    if ( is_null($res_obj->user) ) { 
	    watchdog('waf_notifier', 'Notify failed to ' . $client->waf_client_site_service_url . ' error:'
        . $res_obj->error->error_code . " " . $res_obj->error->error_message );
      return FALSE;
    }
    return TRUE;
  }
}

/*
 * Add a set of jobs for each client to the notifier_queue
 * for process later via the cron. 
 *
 * @param string $service_name
 * @param string $sso_id
 */
function waf_notifier_add_user_update_queue($service_name, $sso_id) {
wdd('waf_notifier_add_user_update_queue');
wdd($service_name, 'service_name=');
wdd($sso_id, 'sso_id=');

  //get the queue
  $queue = DrupalQueue::get('notifier_queue');

  $queue->createQueue();

  //go through the clients and add one for each client
  //except the one which sent the update
  $notify_clients = waf_client_get_clients();
  foreach ($notify_clients as $client) {
    if ( $client->service_name != $service_name ) {

      //create job
      $job = array(
        'service_name' => $client->service_name,
        'sso_id' => $sso_id,
        'client' => $client,
      );

      //add to queue
      $queue->createItem($job);
    }
  }
}

/*
 * Called via cron this service will process the
 * notifier queue. Each job will be sent to
 * waf_notifier_notify_client for processing.
 * If it is sucessfully processes it will be delete
 * off the the queue if not it will remain on the queue
 * to be tried later.
 */

function waf_notifier_process_queue() {
wdd("waf_notifier_process_queue");

  //get the queue
  $queue = DrupalQueue::get('notifier_queue');

  if ( is_null($queue) ) {
    $queue->createQueue();
  }

  //read the items on the queue
  while ( ($item = $queue->claimItem()) !== FALSE ) {

    //check this is a valid job
    if ( isset($item->data) ) {
      $job = $item->data;

      //notifiy the clients of the job
      if ( waf_notifier_notify_client($job['client'], $job['sso_id']) ) {
        //success now delete the job
        $queue­>deleteItem($item);
      } 
      else {
        //ok we failed, there should be something in watchdog
        //on why it failed but we will retry later.
        $queue­>releaseItem($item);
      }
    } 
    else {
        //delete the job as its corrupt
        $queue­>deleteItem($item);
    }
  }
}

/*
 * Implmentation of hook_cron
 */
function waf_notifier_cron() {
wdd("waf_notifier_cron");

  waf_notifier_process_queue();

}

